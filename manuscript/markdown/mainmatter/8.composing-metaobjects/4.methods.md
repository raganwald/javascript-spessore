## Overriding and Specializing Methods

Many languages, including JavaScript, implement "override by default." When you assign a function to a property in a prototype, you overwrite whatever method may have been previously bound to that property in the prototype, and you override any method bound to that property higher in the prototype chain.

When that's what we want to do, we're free to resolve the methods we wish to override with `{override: 'someMethod'}` But we also have the option to extend methods with `before`, `after`, and `around`.

Up to now, we've considered resolving conflicts as a way to handle the case when two behaviours both have a method with the same name, and both methods are roughly equal in importance. This is the case when an `initialize` method conflicts. But sometimes, we have behaviour that is intended to extend another behaviour's implementation of a method.

For example, if someone has children and has a parent, then adding to their children also adds their parent's grandchildren:

~~~~~~~~
var HasChildren = encapsulate({
  initialize: function () {
    this._children = [];
    return this;
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  children: function () {
    return this._children;
  }
});

var HasGrandchildren = encapsulate({
  initialize: function () {
    this._grandchildren = [];
    return this;
  },
  addGrandchild: function (name) {
    this._grandchildren.push(name);
    return this;
  },
  grandchildren: function () {
    return this._grandchildren;
  }
});

var HasParent = encapsulate({
  addParent: function (parent) {
    this._parent = parent;
    return this;
  },

  addChild: function (name) {
    this._parent.addGrandchild(name);
  }
});

var gwen = Object.create(HasGrandchildren).initialize(),
    IsParentAndChild = composeBehaviours(
      HasChildren,
      resolve(HasParent, {addChild: 'after'})
    ),
    reg = Object.create(IsParentAndChild).initialize();

reg.addParent(gwen);
reg.addChild('Clara');
reg.addChild('Thomas');

gwen.grandchildren()
  //=> [ 'Clara', 'Thomas' ]
~~~~~~~~

*TODO: First write addChild where we repeat ourselves, then write the decoration version*

The general model of children, parents and grandchildren is flawed, but for the moment let's look at what's wrong with the code for implementing the behaviour and not the behaviour itself. `HasParent.addChild` clearly makes no sense on its own, it exists to "decorate" `HasChildren.addChild`.

So we always have to write `resolve(HasParent, {addChild: 'after'})`. This is error-prone. Furthermore, there is no way to check that we actually are decorating a method that already exists. What if we forget?

Instead, let's directly write `HasParent` with the resolution "baked in:"

~~~~~~~~
var HasParent = {
  addParent: function (parent) {
    this._parent = parent;
    return this;
  },

  addChild: {after: function (name) {
    this._parent.addGrandchild(name);
  }}
}

var IsParentAndChild = composeBehaviours(HasChildren, HasParent),
    gwen = Object.create(HasGrandchildren).initialize(),
    reg = Object.create(IsParentAndChild).initialize();

reg.addParent(gwen);
reg.addChild('Clara');
reg.addChild('Thomas');

gwen.grandchildren()
  //=> [ 'Clara', 'Thomas' ]
~~~~~~~~

This version of `AddParent` does not need `resolve`. We did not do this with methods like `HasChildren` above, because they made sense on their own. But as we've written it, `HasParent` must always decorate an `addChild` method, so it makes sense to write the resolution directly into the behaviour.

Furthermore, we now have a way of checking that we are composing HasParent with behaviour that already defines `addChild`:

~~~~~~~~
var HasGrandchildrenAndParent = composeBehaviours(HasGrandchildren, HasParent)
  //=> 'addChild' is not conflicted, but was given a resolution
~~~~~~~~

This is very helpful, as it prevents us from making a mistake. Our implementation *expects* to decorate `addChild`, so it's a good thing that `composeBehaviours` detects the problem.

*TODO: write a closure checker that works on a single behaviour*

### resolving methods by name

There are other ways to "signal" that we want certain methods to decorate existing methods. Many frameworks use naming conventions. We could, for example, design things so that if we write `save`, we want a save method, but if we write `afterSave`, we want to decorate an existing `save` method:

~~~~~~~~
//////////////////////////////////////////////////
//
//////////////////////////////////////////////////

var __slice = [].slice;

function extend () {
  var consumer = arguments[0],
      providers = __slice.call(arguments, 1),
      key,
      i,
      provider;

  for (i = 0; i < providers.length; ++i) {
    provider = providers[i];
    for (key in provider) {
      if (Object.prototype.hasOwnProperty.call(provider, key)) {
        consumer[key] = provider[key];
      };
    };
  };
  return consumer;
};

var policies = {
  overwrite: function overwrite (fn1, fn2) {
    return fn2;
  },
  discard: function discard (fn1, fn2) {
    return fn1;
  },
  before: function before (fn1, fn2) {
    return function () {
      fn2.apply(this, arguments);
      return fn1.apply(this, arguments);
    }
  },
  after: function after (fn1, fn2) {
    return function () {
      fn1.apply(this, arguments);
      return fn2.apply(this, arguments);
    }
  },
  around: function around (fn1, fn2) {
    return function () {
      var argArray = [fn1.bind(this)].concat(__slice.call(arguments, 0));
      return fn2.apply(this, argArray);
    }
  }
};

//////////////////////////////////////////////////

function resolveByName (behaviour) {
  var result = Object.create(null);

  Object.keys(behaviour).forEach(function (methodName) {
    var resolver = Object.keys(policies).reduce(function (acc, policy) {
      if (Object.keys(acc).length === 0) {
        var regex = new RegExp("^" + policy + "([A-Z])(.*)$"),
            actualMethodName;
        if (md = methodName.match(regex)) {
          actualMethodName = md[1].toLowerCase() + md[2];
          acc[actualMethodName] = {};
          acc[actualMethodName][policy] = behaviour[methodName];
        }
      }
      return acc;
    }, Object.create(null))
    if (Object.keys(resolver).length === 0) {
      result[methodName] = behaviour[methodName];
    }
    else extend(result, resolver);
  });

  return result;
}

resolveByName({
  toString: undefined,

  beforeSave: function () {
    console.log("saving " + this.toString());
  }
})
  //=>
    { toString: undefined,
      save: { before: [Function] } }
~~~~~~~~
