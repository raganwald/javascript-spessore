## Sequences of Metaobjects

Up to now, we've combined behaviours in an object (such as to create a prototype) using `extend` to forcibly copy the methods from our behaviours into an empty object. The core of `extend` is this block:

~~~~~~~~
for (key in provider) {
  if (Object.prototype.hasOwnProperty.call(provider, key)) {
    consumer[key] = provider[key];
  };
};
~~~~~~~~

We evaluate `consumer[key] = provider[key];` for each method in our behaviour. This has the desired effect when we're composing two behaviours that have a disjoint set of methods. But if they both have a method with the same name, one will overwrite the other.

This is almost never the right thing to do. If you think about composition, what we want is that if we have a behaviour `A` and a behaviour `B`, we want the behaviour `AB` to be both `A` *and* `B`. If we have some expectation about the behaviour of `A`, we should have the same expectation of `AB`.

If `A` and `B` both define a method, `m()`, then calling `AB.m()` should be equivalent to calling `A.m()`. This is not the case if `B.m` overwrites `A.m`. Likewise `AB.m()` should also be equivalent to calling `B.m()`. We want `AB.m()` to be equivalent to *both* `A.m()` and `B.m()`.

For example:

~~~~~~~~
var SingsSongs = encapsulate({
  _songs: null,

  initialize: function () {
    this._songs = [];
    return this;
  },
  addSong: function (name) {
    this._songs.push(name);
    return this;
  },
  songs: function () {
    return this._songs;
  }
});

var HasAwards = encapsulate({
  _awards: null,

  initialize: function () {
    this._awards = [];
    return this;
  },
  addAward: function (name) {
    this._awards.push(name);
    return this;
  },
  awards: function () {
    return this._awards;
  }
});

var AwardWinningSongwriter = extend(Object.create(null), SingsSongs, HasAwards),
    tracy = Object.create(AwardWinningSongwriter).initialize();

tracy.songs()
  //=> undefined
~~~~~~~~

`HasAwards.initialize` has overwritten `SingsSongs.initialize`, exactly what we said it should not do.

### composing methods

We know a little something about composing methods from [Meta-Methods](#meta-methods). One way to compose two methods is to evaluate one and then the other. Here's what a very simple version looks like for functions. We'll call it `strategy`:

~~~~~~~~
function simpleOrderStrategy (fn1, fn2) {
  return function sequenced () {
    fn1.apply(this, arguments);
    return fn2.apply(this, arguments);
  }
}
~~~~~~~~

Using this formulation, we can say that given `A.m` and `B.m`, then `AB.m = simpleOrderStrategy(A.m, B.m)`.

We can promote this idea to sequencing metaobjects. First, we generalize `simpleOrderStrategy` to handle an number of functions and the degenerate case of one function. We can then write `sequence` to apply this to encapsulated methods:

~~~~~~~~
var __slice = [].slice;

function isUndefined (value) {
  return typeof value === 'undefined';
}

function isntUndefined (value) {
  return typeof value !== 'undefined';
}

function isFunction (value) {
  return typeof value === 'function';
}

function orderStrategy () {
  if (arguments.length === 1){
    return arguments[0];
  }
  else {
    var fns = arguments;
    return function sequenced () {
      for (var i = 0; i < (fns.length - 1); ++i) {
        fns[i].apply(this, arguments);
      }
      return fns[fns.length - 1].apply(this, arguments);
    }
  }
}

function propertiesToArrays (metaobjects) {
  return metaobjects.reduce(function (collected, metaobject) {
    Object.keys(metaobject).forEach(function (key) {
      if (key in collected) {
        collected[key].push(metaobject[key]);
      }
      else collected[key] = [metaobject[key]]
    });
    return collected;
  }, {})
}

function resolveUndefineds (collected) {
  return Object.keys(collected).reduce(function (resolved, key) {
    var values = collected[key];

    if (values.every(isUndefined)) {
      resolved[key] = undefined;
    }
    else resolved[key] = values.filter(isntUndefined);

    return resolved;
  }, {});
}

function applySequenceFn(resolveds, protocol) {
  return Object.keys(resolveds).reduce( function (applied, key) {
    var value = resolveds[key];

    if (isUndefined(value)) {
      applied[key] = value;
    }
    else if (value.every(isFunction)) {
      applied[key] = protocol.apply(null, value);
    }
    else throw "Don't know what to do with " + value;

    return applied;
  }, {});
}

function sequence () {
  var metaobjects = __slice.call(arguments, 0),
      arrays      = propertiesToArrays(metaobjects),
      resolved    = resolveUndefineds(arrays),
      sequenced   = applySequenceFn(resolved, orderStrategy);

  return sequenced;
}
~~~~~~~~

Let's revisit our example from above, but this time we'll `sequence` our metaobjects instead of `extending` an object:

~~~~~~~~
var SingsSongs = encapsulate({
  _songs: null,

  initialize: function () {
    this._songs = [];
    return this;
  },
  addSong: function (name) {
    this._songs.push(name);
    return this;
  },
  songs: function () {
    return this._songs;
  }
});

var HasAwards = encapsulate({
  _awards: null,

  initialize: function () {
    this._awards = [];
    return this;
  },
  addAward: function (name) {
    this._awards.push(name);
    return this;
  },
  awards: function () {
    return this._awards;
  }
});

var AwardWinningSongwriter = sequence(SingsSongs, HasAwards),
    tracy = Object.create(AwardWinningSongwriter).initialize();

tracy.addSong('Fast Car');
tracy.songs()
  //=> [ 'Fast Car' ]
~~~~~~~~

Now `AwardWinningSongwriter.initialize` does exactly what we want it to do.

### return value protocols

Our `orderStratgey` is very simple. But there are some cases it doesn't handle well. Sometimes we want to decorate a method with some behaviour, but not take over the return value.

This often happens when we have two responsibilities, but they are not "peers:" One is a primary responsibility, while the other is a secondary and lesser responsibility.

For example, a `Songwriter`'s responsibility is to manage its songs:

~~~~~~~~
var Songwriter = encapsulate({
  initialize: function () {
    this._songs = [];
    return this.self;
  },
  addSong: function (name) {
    this._songs.push(name);
    return this.self;
  },
  songs: function () {
    return this._songs;
  }
});
~~~~~~~~

Secondary responsibilities are often orthogonal concerns. Waving aside ECMAScript-6's [`Object.observe`][observe] for a moment, we could design a program that has views that are notified when models that delegate to `Songwriter` are changed. We would start with the basic idea that something like a view could "subscribe" to a model that is a `Subscribable`:

[observe]: http://wiki.ecmascript.org/doku.php?id=harmony:observe

~~~~~~~~
var Subscribable = encapsulate({
  initialize: function () {
    this._subscribers = [];
    return this.self;
  },
  subscribe: function (callback) {
    this._subscribers.push(callback);
  },
  unsubscribe: function (callback) {
    this._subscribers = this._subscribers.filter( function (subscriber) {
      return subscriber !== callback;
    });
  },
  subscribers: function () {
    return this._subscribers;
  },
  notify: function () {
    receiver = this;
    this._subscribers.forEach( function (subscriber) {
      subscriber.apply(receiver.self, arguments);
    });
  }
});
~~~~~~~~

A `SubscribableSongWriter` would obviously be `sequence(Songwriter, Subscribable)`. But in order for subscribing to be useful, we want `notify()` to be called whenever we call `addSong()`. We can do that by adding more behaviour to `addSong`:

~~~~~~~~
var SubscribableSongWriter = sequence(
  Songwriter,
  Subscribable,
  encapsulate({
    notify: undefined,
    addSong: function () { this.notify(); }
  })
);

var sweetBabyJames = Object.create(SubscribableSongWriter).initialize();
~~~~~~~~

The third metaobject, `encapsulate({notify: undefined, addSong: function () { this.notify(); }})`, appends a behaviour to `addSong` that calls `notify()` when a song is added. We can see that it works using this primitive "view:"

~~~~~~~~
var SongwriterView = {
  initialize: function (model, name) {
    this.model = model;
    this.name = name;
    this.model.subscribe(this.render.bind(this));
    return this;
  },
  _englishList: function (list) {
    var butLast = list.slice(0, list.length - 1),
        last = list[list.length - 1];
    return butLast.length > 0
           ? [butLast.join(', '), last].join(' and ')
           : last;
  },
  render: function () {
    var songList  = this.model.songs().length > 0
                    ? [" has written " + this._englishList(this.model.songs().map(function (song) {
                        return "'" + song + "'"; }))]
                    : [];

    console.log(this.name + songList);
    return this;
  }
}

var jamesView = Object.create(SongwriterView).initialize(sweetBabyJames, 'James Taylor');

sweetBabyJames.addSong('Fire and Rain')
  //=> James Taylor has written 'Fire and Rain'
       undefined
~~~~~~~~

Or did it work? Let's look at `Songwriter.addSong`:

~~~~~~~~
function (name) {
  this._songs.push(name);
  return this.self;
}
~~~~~~~~

It is supposed to return `this.self`, but it actually returns `undefined`, because it is returning whatever the last `addSong` behavior returns. The last behaviour is `function () { this.notify(); }`, and that doesn't return anything at all, so we get `undefined`.

This is almost never what we want. We could "fix" `function () { this.notify(); }` to return `this.self`, but the larger issue is that `function () { this.notify(); }` is a secondary responsibility. It shouldn't know what is to be returned.

What we want is to be able to sequence behaviour, but make responsibility for the return value optional. We'll do that with a simple convention: Not returning a value, or returning `undefined`, advertises that a function does not have responsibility for the return value.

We can implement this with a simple change to our ordering strategy:

~~~~~~~~
var __slice = [].slice;

function isntUndefined (value) {
  return typeof value !== 'undefined';
}

function orderStrategy2 () {
  if (arguments.length === 1) {
    return arguments[0];
  }
  else {
    var fns = __slice.call(arguments, 0);

    return function sequenced () {
      var args    = arguments,
          context = this,
          values  = fns.map(function (fn) {
            return fn.apply(context, args);
          }).filter(isntUndefined);

      if (values.length > 0) {
        return values[values.length - 1];
      }
    }
  }
}

function sequence () {
  var metaobjects = __slice.call(arguments, 0),
      arrays      = propertiesToArrays(metaobjects),
      resolved    = resolveUndefineds(arrays),
      sequenced   = applySequenceFn(resolved, orderStrategy2);

  return sequenced;
}

var CorrectSubscribableSongWriter = sequence(
  Songwriter,
  Subscribable,
  encapsulate({
    notify: undefined,
    addSong: function () { this.notify(); }
  })
);

var sweetBabyJames = Object.create(CorrectSubscribableSongWriter).initialize();

var jamesView = Object.create(SongwriterView).initialize(sweetBabyJames, 'James Taylor');

sweetBabyJames.addSong('Fire and Rain') === sweetBabyJames
  //=> James Taylor has written 'Fire and Rain'
       true
~~~~~~~~

Success! It now returns the original value, the receiver, as we intended.

I> One consequence of returning the last non-`undefined` value is that it is possible to want to return `undefined` but to have that value usurped by another behaviour that returns something other than `undefined`.
I>
I> In practice, this is rare, but if it does arise it will be necessary to work around this limitation or to change strategies.

### specialization and prototype chains

Our scheme for decorating methods with additional behaviour like `addSong: function () { this.notify(); }` works perfectly when we're composing behaviour. This works in concert with prototypes when we're building a single prototype.

What this scheme *can't* do is compose behaviour across prototypes. Although we prefer to avoid creating elaborate prototype chains, let's presume that we have an excellent reason for wanting to create an `Songwriter` prototype, and also create a `SubscribableSongwriter` prototype that delegates to `AwardWinningSongwriter`.

In other words:

![A small prototype chain](images/8/chain.png)

Now we want to make a `SubscribableAwardWinningSongwriter` that delegates to `AwardWinningSongwriter`. There is a trick for making behaviour that delegates to a prototype: We compose the behaviour we want with an object that delegates to the desired prototype. In effect, we're composing the delegation with the behaviour we want.

~~~~~~~~
var SubscribableSongwriter = composeBehaviours(
  Object.create(Songwriter),
  resolve( Subscribable, {initialize: 'after'} ),
  resolveByName(
    encapsulate({
      notify: undefined,
      afterAddSong: function () { this.notify(); }
    })
  )
);
~~~~~~~~

We have what we need to build our object:

~~~~~~~~
var paulSimon = Object.create(SubscribableAwardWinningSongwriter).initialize(),
    paulView  = Object.create(SongwriterView).initialize(paulSimon, 'Paul Simon');

paulSimon.addSong('Cecilia')
  //=> Paul Simon has written 'Cecilia'
       undefined

paulSimon.songs()
  //=> [ 'Cecilia' ]
~~~~~~~~

Why would we do this? Well, for certain styles of programming, we care very much what prototypes are in an object's prototype chain. Note:

~~~~~~~~
AwardWinningSongwriter.isPrototypeOf(sweetBabyJames)
  //=> false

AwardWinningSongwriter.isPrototypeOf(paulSimon)
  //=> true
~~~~~~~~

When we compose behaviours directly, we lose the ability to track their inclusion in the prototype chain. There is no baked-in way to ask whether an object includes the behaviour from `AwardWinningSongwriter`. So why don't we *always* wire behaviours up with prototype chains? As we discussed earlier, prototype chains can only model trees, while composing behaviours provides much more freedom to mix and match compact, focused responsibilities.

When we choose model our behaviour with prototypes, it is still advantageous to use our model for composing behaviour. A na√Øve prototype chain with methods embedded directly in the prototypes has open recursion and suffers from coupling. Using encapsulated behaviours with prototypes decouples prototypes from the object and from each other.
