# Safely Extending Prototypes

Although we don't emphasize it, prototypes can be chained. What happens when we attempt to mix in behaviour that conflicts with a super-prototype?

~~~~~~~~
var SingsSongs = encapsulate({
  initialize: function () {
    this._songs = [];
    return this;
  },
  addSong: function (name) {
    this._songs.push(name);
    return this;
  },
  songs: function () {
    return this._songs;
  }
});

var HasAwards = encapsulate({
  initialize: function () {
    this._awards = [];
    return this;
  },
  addAward: function (name) {
    this._awards.push(name);
    return this;
  },
  awards: function () {
    return this._awards;
  }
});

var AwardWinningSongwriter = composeBehaviours(
  SingsSongs,
  resolve(HasAwards, {initialize: 'after'})
);

var HasChildren = encapsulate({
  initialize: function () {
    this._children = [];
    return this;
  },
  addChild: function (name) {
    this._children.push(name);
    return this;
  },
  children: function () {
    return this._children;
  }
});

var SingsToChildren = Object.create(AwardWinningSongwriter);
extend(SingsToChildren, HasChildren);

var sharon = Object.create(SingsToChildren);
sharon.initialize();

sharon.addAward("Grammy for Best Children's Album")
  //=> TypeError: Cannot call method 'push' of undefined
~~~~~~~~

As we might expect, `HasChildren.initialize` is being copied into `SingsToChildren`, and that's what gets evaluated when we call `sharon.initialize()`. our `composeBehaviour` function never has a chance to resolve it. Let's try:

~~~~~~~~
var SingsToChildren = composeBehaviours(
  Object.create(AwardWinningSongwriter),
  resolve(HasChildren, {initialize: 'after'})
);

var sharon = Object.create(SingsToChildren);
sharon.initialize();

sharon.addAward("Grammy for Best Children's Album");
sharon.awards()
  //=> [ 'Grammy for Best Children\'s Album' ]
~~~~~~~~

Looking good. But then:

~~~~~~~~
AwardWinningSongwriter.isPrototypeOf(sharon)
  //=> false
~~~~~~~~

Our `composeBehaviour` function ignored the prototype and "flattened" all of the behaviour into an object that delegates to `Object.prototype`. This is not what we expect. So we'll rewrite it to respect prototypes.

Now, we can't compose multiple prototypes, JavaScript only allows a single prototype. So we'll use the prototype of the first behaviour, and then check that the rest are compatible with it.

~~~~~~~~
// if a 'is-compatible-wth-b', it means we can happily inherit
// from a. a is the same as b, or a specialization of b. there is some
// extra stuff to handle `null`:

function allEncompasses (prototype1, prototype2) {
  if (prototype1 === null) return prototype2 === null;
  if (prototype2 === null) return true;
  if (prototype1 === prototype2) return true;
  return Object.prototype.isPrototypeOf.call(prototype2, prototype1);
}

function composeBehaviours () {
  var behaviours = __slice.call(arguments, 0),
      seed = extend(Object.create(Object.getPrototypeOf(behaviours[0])), behaviours[0]);

  behaviours[0] = seed;

  return behaviours.reduce(function (composed, behaviour) {
    var definedMethods = methodsOfType(behaviour, 'function'),
        resolutions = methodsThatResolve(behaviour),
        dependencies = methodsOfType(behaviour, 'undefined');

    if (!allEncompasses(Object.getPrototypeOf(composed), Object.getPrototypeOf(behaviour))) {
      throw "incompatible prototypes";
    }

    definedMethods.forEach(function (methodName) {
      if (composed[methodName] === void 0) { // none or a dependency
        composed[methodName] = behaviour[methodName];
      }
      else throw "'" + methodName + "' has a conflict."
    });

    dependencies.forEach(function (methodName) {
      if (composed[methodName] === void 0) { // none or a dependency
        composed[methodName] = void 0;
      }
      else if (typeof(composed[methodName]) !== 'function') {
        throw "'" + methodName + "' conflicts with entry of type '" + typeof(composed[methodName]) + "'";
      }
      // else do nothing, dependency is satisfied
    });

    resolutions.forEach(function (methodName) {
      var resolution = behaviour[methodName],
          policy = Object.keys(resolution)[0],
          resolutionPolicy = policies[policy],
          newMethod = resolution[policy],
          existingMethod;

      if (methodName in composed) {
        existingMethod = composed[methodName];
        if (typeof(existingMethod) === 'function') {
          composed[methodName] = resolutionPolicy(newMethod, existingMethod);
        }
        else throw "'" + methodName + "' is attempting to resolve a '" + typeof(existingMethod) + "'";
      }
      else throw "'" + methodName + "' is not conflicted, but was given a resolution"
    });

    return composed;
  });
}

var SingsToChildren = composeBehaviours(
  Object.create(AwardWinningSongwriter),
  resolve(HasChildren, {initialize: 'after'})
);

var sharon = Object.create(SingsToChildren);

Object.prototype.isPrototypeOf.call(AwardWinningSongwriter, sharon)
~~~~~~~~